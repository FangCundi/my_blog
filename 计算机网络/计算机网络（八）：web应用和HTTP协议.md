二、web应用和HTTP协议
1、HTTP概况：
web应用层协议是超文本传输协议HTTP，是web的核心。
HTTP协议由两部分程序实现：一个客户机程序和一个服务器程序，他们运行在不同的端系统中，通过交换HTTP报文进行会话。
对象：简单来说就是文件，这些文件可通过一个URL地址寻址。
web页面（文档）：是由对象组成的，多数web页面含有一个基本HTML文件以及几个引用对象
基本HTML文件：在基本HTML文件中通过对象的URL地址对对象进行引用。
URL地址：由两部分组成：存放对象的服务主机名和对象的路径名。例如URL地址http://www.somesc.edu/sd/pic.gif中的www.somesc.edu就是主机名（域名），而/sd/pic.gif就是路径名。
web浏览器：实现了HTTP的客户机端
web服务器：存储web对象，对象由URL寻址，实现了HTTP的服务器端
HTTP采用TCP而不是UDP作为他的支持运输层协议，进行数据传输服务。采用的是CS模式。首先要建立到服务器的连接，建立完连接才能传输信息。
分层结构最大的优点，即HTTP协议不用担心数据丢失，也不用担心TCP是如何从网络的数据丢失和乱序故障中恢复的，那是TCP和协议栈低层协议的工作。web服务器总是打开的，具有一个固定的IP地址，服务于不同的浏览器。
服务器向客户机发送被请求的文件时，并不存储任何关于该客户机的状态信息，假如一个客户机在短时间内多次访问，服务器不会因为刚刚提供了服务就不再做出反应，而是重新发送该对象。一个HTTP服务器并不保存关于客户机的任何信息，所以我们说HTTP是一个无状态协议。
使用请求的基本步骤：不需要进行多媒体数据与ASCII码的转换！！！
①、客户端发起TCP连接，目的端口号为80（80指向的就是一个web应用）；建立连接是传输层的任务。
②、服务器接收请求，在服务器上发送应用层的HTTP
③、给出响应
④、TCP连接关闭，资源释放
2、非持久连接和持久连接：
默认方式下HTTP使用持久连接。
a、非持久连接：
每个请求/响应对是经一个单独的TCP连接发送。
非持久连接下，请求处理的具体过程：以http://www.somesc.edu/sd/home.index为例
①、客户机进程在端口号80发起一个到服务器www.somesc.edu的TCP连接，该端口号是HTTP的默认端口，客户机和服务器上分别有一个套接字与该连接相关联。
②、客户机经他的套接字向服务器发送一个HTTP请求报文。请求报文中包含了路径名sd/home.index
③、服务器进程经他的套接字接收该请求报文，从其存储器（RAM或磁盘）中检索出对象sd/home.index，在一个HTTP响应报文中封装对象，并通过其套接字向客户机发送响应报文
④、服务器进程通知TCP断开该TCP连接，直到TCP确认客户机已经完整地接收到响应报文后，真正中断连接
⑤、客户机接收响应报文，TCP连接关闭。报文指出封装的对象是一个HTML文件，客户机从响应报文中提取出该文件，检查该文件。
⑥、如果得到的文件是某些对象的应用，那么会重复前四步，直到拿到所有的对象。
非持久连接的使用，每个TCP连接在服务器返回对象后关闭，即该连接并不为其他的对象而持续下来。每个TCP连接只传输一个请求报文和一个响应报文。
用户可以设置浏览器以控制并行度。默认情况下浏览器可以允许5-10个并行的TCP链接，每一个链接处理一个请求-响应事物。一般来讲使用并行链接可以缩短响应时间。
往返时间RTT：一个小分组从客户机到服务器再返回客户机所需要的时间。包括分组传播时延、分组在中间路由器和交换机上的排队时延和分组处理时延。
三次握手：浏览器在浏览器和web服务器之间发起一个TCP连接，会有三次：
①、客户机向服务器发送一个小TCP报文段
②、服务器用一个小TCP报文段做出确认和响应
③、客户机向服务器返回确认
一个RTT等于三次握手中两个部分所耗费的时间。完成了三次握手的前两个部分后，客户机将三次握手的第三个部分（确认）与一个HTTP请求报文结合起来发送到该TCP连接，一旦请求报文到达服务器，服务器向该TCP连接发送HTML文件，该HTML请求/响应又耗掉一个RTT。
总的响应时间=两个RTT+服务器传输HTML文件的时间。
缺点：①为每个请求的对象建立和维护一个全新的连接，都要分配TCP的缓冲区和变量；②每个传输时延为两个RTT；③每个对象都要经历TCP缓启动。
b、持久连接：
所有的请求及相应的响应经相同的TCP连接发送。
持久连接下，服务器在发送响应后保持该TCP连接打开，可以在单个TCP连接上进行，对这些对象的请求可一个接一个发出，而不必等待未决请求的回答（流水线）。如果一个连接经过一定时间间隔（一个可配置的超时间隔）仍未被使用，服务器就关闭该连接。
HTTP默认使用流水线方式的持久连接。
3、HTTP报文格式：
HTTP报文有两种：请求报文和响应报文
a、HTTP请求报文：
GET /sd/pa.html HTTP/1.1
Host: www.ssc.edu
Connection: close
User-agent: Mozilla/4.0
Accept-Language: fr
注意，这里有一个回车！！！
报文使用普通的ASCII文本书写的，此报文共含有5行，每行用一个回车换行符结束，最后一行后跟有一个附加的回车换行符。但有的报文可能有多或少行。
第一行叫请求行，有三个字段：方法字段、URL字段和HTTP协议版本字段。方法字段可以取值GET\POST\HEAD\PUT\DELETE，绝大部分使用GET，当浏览器请求一个对象时，使用GET方法，在URL字段填写该对象的URL地址。一般来讲1.0的HTTP是非持续的，1.1是持续的。
请求行的后继行为首部行。
首部行Host定义了目标所在的主机。虽然主机已经有一个TCP连接了，但是首部行提供的信息时Web代理高速缓存所要求的；
首部行Connection: close告诉服务器不使用持久连接，要求服务器在发送完被请求的对象后就关闭连接；
首部行User-agent用来定义用户代理，即向服务器发送请求的浏览器的类型。上文的浏览器类型是Mozilla/4.0，即Netscape浏览器。服务器可以根据这个正确地为不同类型的用户代理实际发送相同对象的不同版本，每个版本都由相同的URL处理。
首部行Accept-language表示拥护想得到该对象的法语版本（如果有），否则使用服务器的默认版本。这仅是HTTP众多可选内容协商首部之一。
首部行（和附加的回车换行符）后有一个“实体主体”，使用GET方法时实体主体为空，而使用POST方法时才是用。客户机通常在用户提交表单时使用POST方法。当方法字段的值为POST时，实体主体中包含的就是用户在表单字段中输入的值。实体是由客户端发送到服务端的具体内容。
GET产生1个TCP数据报，header与data一起发送（获取data）；POST会产生2个TCP数据包，先发送header再发送data（提交data）。
用表单生成的请求报文不需要使用POST方法。HTML表单经常使用GET方法，将输入数据（在表单字段内）传送到正确的URL
HEAD方法类似于GET方法，当服务器收到HEAD方法的请求时，会用一个HTTP报文进行相应，但不返回请求对象。可以用他进行故障跟踪。
PUT方法常与web发型工具联合使用，用来上传对象到指定的web上的指定路径。FELETE方法可以删除web服务器上的对象。
b、HTTP响应报文：
HTTP/1.1 200 OK
Connetion:close
Date:Thu, 03 Jul 2003 12:00:15 GMT
Server: Apache/1.3.0 (unix)
Last-Modified:sun, 6 May 2007 09:223:24 GMT
Content-Length: 6821
Content-Type: text/html

(data data data data ...)
初始状态行：有3个字段，即协议版本、状态码和相关信息
请求环境（即首部行形容的环境）：请求时间+运行版本+请求对象最后的更新时间+内容长度+内容类型。
首部行Connection：close告诉客户机在报文发送后关闭了TCP连接
首部行Date指示服务器产生并发送该响应报文的日期和时间。这个时间不是指对象创建或者最后修改的时间，而是服务器从他的文件系统中检索到该对象、插入到响应报文并发送该响应报文的时间
首部行server表明该报文是由一个Apache web服务器产生的，类似于请求报文中的User-agent
首部行Last-Modified指示了对象创建或者最后修改的时间，对既可能在客户机也可能在网络缓存服务器上的对象缓存来说非常重要
首部行Content-Length表明了被发送对象的字节数
首部行Content-Type指示了实体主体中的对象是HTML文本（对象类型应正式的用首部行而不是文件拓展名来指示）
一些常见的状态码和相关的短语：
①、200 OK：请求成功，信息包含在返回的响应报文中
②、301 Moved Permanently：请求的对象已经被永久转移了，新的URL定义在响应报文的location：首部行中指定。客户机软件自动用新的URL获取该对象
③、400 Bad Request：一个通用差错代码，表示请求不能被服务器理解
④、404 Not Found：被请求的文档不在服务器上
⑤、505 HTTP Version Not Supported：服务器不支持请求报文使用的HTTP协议版本
4、用户（并非客户机）与服务器的交互：cookie
如果想要记录状态怎么办？cookie可以记录用户状态且用户可控。
cookie允许站点跟踪用户。有四个组成部分：
①、在HTTP响应报文中有一个cookie首部行
②、在HTTP请求报文中有一个cookie首部行
③、在用户端系统中保留有一个cookie文件，由用户的浏览器管理
④、在web站点有一个后端数据库
cookie具有不可跨域名性。
保存的有Unicode字符或二进制数据（字符串）
根域名不可访问子域的cookie，反之则可以。
cookie工作过程：假设通过internet explorer上网
①、当他第一次访问amazon.com的时候，当请求报文到达amazon web服务器的时候，web站点将产生一个唯一识别码，并以此为索引在他的后端数据库中产生一个表项
②、amazon web服务器用一个包含首部行set-cookie的HTTP响应报文对客户机的浏览器internet explorer进行相应，其中set-cookie含有识别码。
③、当浏览器收到了HTTP响应报文时，他会看到set-cookie首部行，然后浏览器在他管理的特定cookie文件中增加一行，其中包含该服务器的主机名和收到的识别码（set-cookie首部行）。此时，cookie文件已经有了用于ebay的表象，因为曾经访问过（第一次请求报文）。当继续浏览的时候，每请求一个web页面，其浏览器就会从他的cookie文件中获取这个网站的识别码，并放到HTTP请求报文中含有识别码的cookie首部行中。此后，发往服务器的每个请求报文都含有首部行：cookie:识别码。
④、在cookie方式下，服务器可以追踪访问者在该站点的活动。他会把访问者以识别码的形式进行标记和记录。
⑤、如果一个星期后该用户再次访问同一个站点，它的浏览器会在请求报文中继续使用在端系统中保留的cookie文件中的识别码，这样服务器可以在后端数据库中进行搜索，找到保存的有关该用户的数据。如果用户在服务器进行了注册，即提供了他的全名、邮箱地址、邮政地址和信号用卡账号，则会在数据库中记录了这些信息，并将这些信息与识别码关联（以及过去访问的所有页面）。
由此可以知道，cookie可以用于标识客户。用户首次访问站点时，可能需要提供一个用户标识（可能是名字）。在后继访问中浏览器向服务器传递一个cookie首部，提供服务器识别该用户。因此，cookie可以在无状态的HTTP上建立一个用户会话层。
HTTP请求、响应消息的首部行都要包含cookie的首部行。
要有用户主机管理的cookiefile。
后端要有与用户身份相关的数据库。
即使曾经访问过，在换一台电脑后访问仍会被当成新用户，因为cookiefile放在原来的电脑上
5、web缓存：
web缓存器也叫代理服务器，能够代表初始web服务器来满足HTTP请求的网络实体。有自己的磁盘存储空间，可以保留最近请求过的对象的拷贝。
通过代理服务器可以不访问原始的服务器，而是从代理服务器上访问。如果代理服务器上没有这个页面，那么它会代替客户机去访问原始服务器。当代理服务器得到这个页面后，首先将这个页面缓存。
过程如下：
①、浏览器建立一个到web缓存器的TCP连接，并向web缓存器中的对象发送一个HTTP请求
②、web缓存器检查本地是否存储了该对象的拷贝，如果有，web缓存器就用HTTP响应报文向客户机浏览器返回该对象
③、如果没有，就与对象的初始服务器打开一个TCP连接，web缓存器则在TCP连接上发送获取该对象的HTTP请求，在收到请求后，初始服务器向web缓存器发送具有该对象的HTTP响应
④、web缓存器接收到该对象，在他本地存储空间存储了一份拷贝，并用HTTP响应报文向客户机的浏览器发送该报文（通过已经建立在客户机浏览器和web缓存器之间的TCP连接）
web缓存器既是服务器又是客户机。
缺点：网页更新不及时
优点：时延短，可以大大减少对客户机请求的响应时间；节约接入带宽，可以减少一个机构内部网与因特网接入连路上的通信量。
一般而言，web缓存器由ISP购买并安装，并将一个区域网内的所有用户浏览器配置为指向他。
6、条件GET方法：
需要一种机制，以解决缓存器中的对象拷贝可能是陈旧的问题，即可能已经被修改了。因此，条件GET出现了。
如果一个请求报文中使用GET方法，同时请求报文包含一个if-modified-since首部行，则该请求报文就是一个条件GET请求报文。
过程如下：
①、一个代理服务器代表一个请求浏览器，向web服务器发送一个请求报文。
②、web服务器向缓存器发送具有被请求的对象的响应报文
③、缓存器将对象发送到请求浏览器，并保存，同时保存了最后修改时间
④、另一用户通过该缓存器访问同一个对象。
⑤、web缓存器向web服务器发送一个条件GET报文，询问在指定日期之后某对象是否发生修改。
⑥、web服务器返回一个响应报文，如果没有修改直接返回‘304 not modified’并在主体中不包含该对象；如果修改了则返回修改后了的对象？。
是解决更新不及时的一种方式，如果last modified不一致就返回新的，一致则OK，但这个时间不太可靠。
