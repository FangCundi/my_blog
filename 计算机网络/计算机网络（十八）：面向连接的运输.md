## 1、TCP连接：

TCP是面向连接的，因为在一个应用程可以开始向另一个应用进程发送数据之前，这两个进程必须先相互"握手"，即它们必须相互发送某些预备报文段，以建立确保数据传输的参数。
中间路由器对TCP连接完全视而不见，他们看到的是数据包，而不是连接。	TCP连接提供的是全双工服务：如果一台主机上的进程A与另一台主机上的进程B存在一条TCP连接，那么应用层数据就可在从进程B流向进程A的同时，也从进程A流向进程B。
TCP 连接也总是点对点的，即在单个发送方与单个接收方之间的连接。即在 次发送操作中，从一个发送方将数据传送给多个接收方，对TCP来说这是不可能的。
三次握手：客户首先发送一个特殊的TCP报文段，服务器用另一个特殊的TCP报文段来响应，最后，客户再用第三个特殊报文段作为响应。前两个报文段不承载“有效载荷”，也就是不包含应用层数据；而第三个报文段可以承载有效载荷。
客户进程通过套接字(该进程的门)传递数据流 数据一旦通过该门，它就由客户中运行的TCP控制了。
TCP将这些数据引导到该连接的发送缓存里，发送缓存是在三次握手初期设置的缓存之一。接下来TCP就会不时从发送缓存里取出一块数据。
TCP可从缓存中取出并放入报文段中的数据数量受限于最大报文段长度 MSS。MSS通常根据最初确定的由本地发送主机发送的最大链路层帧长度(即所谓的最大传输单元MTU）来设置。
设置该MSS要保证单个链路层帧有一个TCP报文段(当封装在一个IP数据报中)加上TCP/IP首部长度(通常40字节)。以太网和PPP链路层协议都具有1500字节的MTU，因此MSS的典型值为1460字节。已经提出了多种发现路径的方法，并基于路径值设置MSS(路径MTU是指能在从源到目的地的所有链路上发送的最大链路层帧)。注意到MSS是指在报文段里应用层数据的最大长度，而不是指包括TCP首部的TCP报文段的最大长度。
TCP为每块客户数据配上一个TCP首部，从而形成多个TCP报文段。这些报文段被下传给网络层，网络层将其分别封装在网络层IP数据报中。然后这些数据报被发送到网络中。当TCP在另一端接收到一个报文段后，该报文段的数据就被放人该TCP 连接的接收缓存中。应用程序从此缓存中读取数据流。TCP 连接的每一端都有各自的发送缓存和接收缓存。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200428173043930.png)

**TCP 连接的组成包括:一台主机上的缓存、变量和与进程连接的套接字，以及另一台主机上的另一组缓存、变量和与进程连接的套接字**。

## 2、TCP报文段结构

TCP报文段由首部字段和一个数据宇段组成。数据字段包含一块应用数据。MSS限制了报文段数据字段的最大长度。TCP发送一个大文件，通常是将该文件划分成长度为MSS的若干块(最32 比特后一块除外，它通常小于MSS)。然而，交互式应用通常传送长度小于MSS的数据块。
由于TCP的首部一般是 20 字节(比UDP首部多12字节)，所以Telnet发送的报文段也许只有21字节长。
TCP首部包括源端口号和目的端口号，它被用于多路复用/分解来自或送到上 层应用的数据。另外，同UDP一样，首部也包括检验和字段。TCP报文段首部还包含下列字段:
①、32比特的序号字段和32比特的确认号字段：这些字段被TCP发送方和接收方用来实现可靠数据传输服务。
②、16比特的接收窗口字段，该字段用于流量控制。用于指示接收方愿意接受的字节数量。
③、比特的首部长度字段，该字段指示了以32比特的字为单位的TCP首部长度。由于TCP选项字段的原因，TCP首部的长度是可变的(通常，选项字段为空，所以TCP首部的典型长度就是 20 字节。）
④、可选与变长的选项字段，该字段用于发送方与接收方协商最大报文段长度(MSS)时，或在高速网络环境下用作窗口调节因子时使用。
⑤、6比特的标志字段，ACK比特用于指示确认字段中的值是有效的，即该报文段包括一个对已被成功接收报文段的确认。RST、SYN和FIN比特用于连接建立和拆除。PSH比特被设置的时候，就指示接收方应立即将数据交给上层。最后，URG比特用来指示报文段里存在着被发送端的上层实体置为"紧急"的数据 紧急数据的最后一个字节由16比特的紧急数据指针字段指出。当紧急数据存在并给出指向紧急数据尾的指针的时候，TCP必须通知接收端的上层实体(在实践中，PSH，URG和紧急数据指针并没有使用）
TCP把数据看成一个无结构的、有序的字节流。TCP的序号是建立在传送的字节流之上，而不是建立在传送的报文段的序列之上。一个报文段的序号因此是该报文段首字节的字节流编号。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200428173102367.png)

假设主机A上的一个进程想通过TCP连接向主机B上的一个进程发送一个数据流。主机A中的TCP将隐式地对数据流中的每一个字节编号。假定数据流由一个包含500000字节的文件组成，其MSS为1000字节，数据流的首字节编号是0。如该TCP将为该数据流构建500个报文段（每个1000字节）。给第一个报文段分配序号0，第二个报文段分配序号1000，第三个报文段分配序号2000，以此类推。每一个序号被填入到相应TCP报文段首部的序号字段中。
TCP是全双工的，因此主机A在向主机B发送数据的同时，也许也接收来自主机B的数据(都是同一TCP连接的一部分)。从主机B到达的每个报文段中都有一个序号用于从B流向A的数据。
主机A填充进报文段的确认号是主机A想从主机B收到的下一字节的序号。
假设主机A已收到了来自主机B的编号为0-535的所有宇节，同时假设它打算发送一个报文段给主机B。主机A等待主机B的数据流中字节536及之后的所有字节。所以主机A就会在它发往主机B的报文段的确认号字段中填上536。
假设主机A己收到一个来自主机B的包含字节0-535的报文段，以及另一个包含字节900-1000的报文段。由于某种原因，主机A还没有收到字节536 -899
的报文段。在这个例子中，主机A为了重新构建主机B的数据流，仍在等待字节536(和其后的字节)。因此，A到B的下一个报文段将在确认号字段中包含536。因为TCP只确认该流中至第一个丢失字节为止的字节，所以TCP被称为提供累积确认。
**简单地讲，TCP的双方都是可以通信的，发送方可以接受到接收方提示的需要哪一个字节（特指是字节，而不是哪一个报文段），而接收方也可以接收到发送方发送的数据。**
以Telnet为例，想要发送‘c’这个字符。首先客户机向服务器发送第一个报文段，报文段中包含字符‘c’的ASCII码；然后服务器向客户机发送第二个报文段，向客户机发送一个确认，同时回显字符‘c’；最后客户机向服务器发送第三个报文段，确认已从服务器收到的数据，其中的数据字段为空。

## 3、往返时间的估计与超时：

TCP采用超时/重传机制来处理报文段的丢失。重点问题就是超时间间隔长度的设置，超时间隔必须大于该连接的往返时间RTT，即从一个报文段发出到他被确认的时间，否则会造成不必要的重传。
TCP 维持一个SampleRTT均值(称为EstimatedRTT)，即加权平均值。一旦获得一个新 SampleRTT时，TCP 就会根据下列公式来更新。参考值是α=0.125
EstimatedRTT = (1 -α)xEstimatedRTT +αxSampleRTT
超时间隔应该大于等于EstimatedRTI，否则，将造成不必要的重传。但是超时间隔也不应该比EstimatedRTT大太多，否则当报文段丢失时，TCP不能很快地重传该报文段，导致数据传输时延大。因此要求将超时间隔设为EstimatedRTT加上一定余量SampleRTT值波动较大时，这个余量应该大些;当波动较小时，这个余量应该小些。因此，DevRTT值应该在这里发挥作用了TCP的确定重传超时间隔的方法中，所有这些因素都考虑到了:
TimeoutInterval = EstimatedRTI +4xDevRTI

## 4、可靠数据传输：

因特网的网络层服务（IP 服务)是不可靠的。不保证数据报的交付，不保证数据报的按序交付，也不保证数据报中数据的完整性。对lP服务，数据报能够溢出路由器缓存而永远不能到达目的地，数据报也可能是乱序到达，而且数据报中的比特可能损坏。由于运输层报文段是被IP数据报携带着在网络中传输的，所以运输层的报文段也会遇到这些问题。
TCP在lP不可靠的尽力而为服务之上创建了一种可靠数据传输服务。TCP的可靠数据传输服务确保一个进程从其接收缓存中读出的数据流是无损坏、无间隔、非冗余和按序的数据流;即该字节流与连接的另一方端系统发送出的字节流是完全相同。
TCP发送方有3个与发送和重传有关的主要事件：
①、从上层应用程序接收数据;
②、定时器超时；
③、收到ACK；
一旦第一个主要事件发生，TCP从应用程序接收数据，将数据封装在一个报文段中，并把该报文段交给IP注意到每一个报文段都包含一个序号，如报文段第1个数据字节的字节流编号。
注意到如果定时器还没有为某些其他报文段而运行，则当报文段被传给IP时，TCP就启动该定时器(将定时器想象为与最早的未被确认的报文段相关联是有帮助的 )该定时器的过期间隔是TimeouUnlerval。
第二个主要事件是超时TCP通过重传引起超时的报文段来响应超时事件 然后TCP重启定时器。
第三个主要事件是一个来自接收方的确认报文段(ACK)的到达(更确切地说是一个包含了有效ACK字段值的报文段)当该事件发生时，TCP将ACK的值y与它的变量SendBase进行比较。TCP状态变量SendBase是最早未被确认的字节的序号。因此SendBase-1是指接收方已正确按序接收到的数据的最后一个字节的序号。
TCP采用累积确认，所以y确认了字节编号在y之前的所有字节都已经收到。如果y>SendBase，则该ACK是在确认一个或多个先前未被确认的报文段。因此发送方更新它的SendBase变量；如果当前有未被确认的报文段，TCP还要重新启动定时器。

### a、一些有趣的情况：

①、主机A向主机B发送一个报文段。假设该报文段的序号是92，而且包含8字节数据。在发出该报文段之后，主机A等待一个来自主机B的确认号为100的报文段。虽然A发出的报文段在主机B上被收到，但从主机B发往主机A的确认报文丢失了。在这种情况下，超时事件就会发生，主机A会重传相同的报文段。当然，当主机B收到该重传的报文段时，它将通过序号发现该报文段包含了早已收到的数据。因此，主机B中的TCP将丢弃该重传的报文段中的这些字节。即如果发送了多个报文段的时候，会有多个ACK等待接受，会先比较后丢弃。
②、主机A连续发回了两个报文段。第一个报文段序号是92，包含8字节数据;第二个报文段序号是100，包含20字节数据。假设两个报文段都完好无损地到达主机B，并且主机B为每一个报文段分别发送一个确认。第一个确认报文的确认号是100，第二个确认报文的确认号是120。现在假设在超时之前这两个报文段中没有一个确认报文到达主机A。当超时事件发生时，主机A重传序号92的第一个报文段，并重启定时器。只要第二个报文段的ACK在新的超时发生以前到达，则第二个报文段将不会被重传。也就是说，超时事件发生之后，两个ACK之间是不会相互影响的。
③、假设主机A与在第二种情况中完全一样，发送两个报文段。第一个报文段的确认报立在网络丢失，但在超时事件发生之前主机A收到一个确认 号为120的确认报文。主机A因而知道主机B已经收到了序号为119及之前的所有字节; 所以主机A不会重传这两个报文段中的任何一个。也就是说，在超时事件发生之前，两个ACK之间是有影响的，只要后面的确认了，前面的就不需要再次确认。

### b、超时间隔加倍：

这是大多数TCP实现之中所做的一些修改。
在这种修改中，每当超时事件发生时，TCP重传具有最小序号的还未被确认的报文段。只是每次TCP重传时都会将下一次的超时间隔设为先前值的两倍，而不是用从EstimatedRTT和DevRTT推算出的值。
如当定时器第一次过期时，与最早的未被确认的报文段相关联的timeputinterval是0.75秒，TCP就会重传该报文段，并把新的过期时间设置为1.5秒。如果1.5秒后定时器又过期了，则TCP将再次重传该报文段，并把过期时间设置为3.0秒。因此，超时间隔在每次重传后会呈指数型增长。然而，每当定时器在另两个事件(即收到上层应用的数据和收到ACK)中的任意一个启动时，Timeoutlnterval由最近的EstimaledRTT值与DevRTT值推算得到。
**这种修改提供了一个形式受限的拥塞控制，定时器过期很可能是由网络拥塞引起的，即太多的分组到达源与目的地之间路径上的一台(或多台)路由器的队列中，造成分组丢失或长时间的排队时延。在拥塞的时候，如果源持续重传分组，会使拥塞更加严重。相反，TCP使用更文雅的方式，每个发送方的重传都是经过越来越长的时间间隔后进行的**。

### c、快速重传：

超时触发重传存在的问题之一是超时周期可能相对较长。当一个报文段丢失时，这种长超时周期迫使发送方延迟重传丢失的分组，因而增加了端到端时延。
冗余ACK就是再次确认某个报文段的ACK，而发送方先前已经收到对该报文段的确认。
因为TCP不使用否定确认，所以接收方不能向发送方发一个显式的否定确认。相反，它只是对已经接收到的最后一个按序字节数据进行重复确认(即产生一个冗余ACK)。
**即比期望序号大的失序报文段到达，检测出了间隔，即可能发生了报文段丢失，就会立刻发送冗余ACK，用来指示下一个期待字节的序号。如假如我要传送1.2.3.4，现在接收到了1.3，2可能发生了丢失，那么就发送对1的ACK信号，指示我想要2**。
如果TCP发送方接收到对相同数据的3个冗余ACK，它把这当作一种指示，说明跟在这个已被确认过3次的报文段之后的报文段已经丢失。一旦收到3个冗余ACK，TCP就执行快速重传，即在该报文段的定时器过期之前重传丢失的报文段。**简单地讲，就是在重复接收到3个某一个报文段的冗余ACK的时候，就认为他之后的报文段发生了丢失，不管有没有发生超时，立刻进行重传**。

### d、回退N步还是选择重传：

TCP确认是累积式的，正确接收但失序的报文段是不会被接收方逐个确认的。所以说有一点像GBN ，但许多TCP实现会将正确接收但失序的报文段缓存起来。所以TCP选择的是一种选择确认的机制。
它允许TCP接收方有选择地确认失序报文段，而不是累积地确认最后一个正确接收的有序报文段。当将该机制与选择重传机制结合起来使用时(即跳过重传那些已被接收方选择性地确认过的报文段)，TCP看起来就很像我们通常的SR协议。**就是选择性缓存**。

## 5、流量控制：

一条TCP连接每一侧主机都为该连接设置了接收缓存。当该TCP连接收到正确、按序的字节后，它就将数据放入接收缓存。相关联的应用进程会从该缓存中 读取数据，但不必是数据刚到达就立即读取。
TCP为它的应用程序提供了流量控制服务以消除发送方使接收方缓存溢出的可能性，即发送方的发送速率与接收方应用程序的读取速率相匹配。前面提到过，TCP发送方也可能因为IP网络的拥塞而被遏制；这种形式的发送方的控制被称为拥塞控制。
**即使流量控制和拥塞控制采取的动作非常相似(对发送方的遏制)，但是它们显然是针对完全不同的原因而采取的措施**。
TCP通过让发送方维护一个称为接收窗口的变量来提供流量控制。通俗地说，接收窗口用于给发送方一个指示——该接收方还有多少可用的缓存空间。就是把这个变量插入到接收方发送的报文段中，用于告诉发送方还有多少空间可以使用。当主机B的接收窗口为0时（缓存空间为0），主机A继续发送只有一个字节数据的报文段。这些报文段将会被接收方确认，最终缓存将开始清空，并且确认报文里将包含一个非0缓存空间变量rwnd。
**简单地讲，流量控制是因为网络太好，导致发送方发送太快，接收方的缓存空间不够而导致出错或者丢失的控制，是一个发送方与接收方的速度匹配问题，是在端上的控制。拥塞控制是因为网络不好，导致路由器发生了排队，导致丢包，是在网络核心上的控制**。
UDP并不提供流量控制。对于一个典型的UDP实现，UDP将会把报文段添加到相应套接字(进程的门户)"前面"的一个有限大小的缓存中，进程每次从缓存中读取一个完整的报文段。如果进程从缓存中读取报文段的速度不够快，那么缓存将会溢出，并且将丢失报文段。

## 6、TCP连接管理：

TCP连接的建立会显著地增加人们感受到的时延。假设运行在一台主机(客户)上的一个进程想与另一台主机(服务器)上的一个进程建立一条连接。客户应用进程首先通知客户TCP，它想建立一个与服务器上某个进程之间的连接。客户中的TCP会用以下方式与服务器中的TCP建立一条TCP连接（三次握手）:
①、第一步：客户端的TCP首先向服务器端的TCP发送一个特殊的TCP报文段。该报文段中不包含应用层数据，但是在报文段的首部中的一个标志位(即SYN比特)被置为1。因此，这个特殊报文段被称为SYN报文段。另外，客户会随机地选择一个初始序号client_isn，并将此编号放置于该起始的TCP SYN报文段的序号字段中。该报文段会被封装在一个IP数据报中，并发送给服务器。**即“我想建立连接，因此发送了一个SYN分组，我的初始序号为client_isn”**。
②、第二步：一旦包含TCP SYN报文段的IP数据报到达服务器主机，服务器会从该数据报中提取出TCP SYN报文段，为该TCP连接分配TCP缓存和变量，并向该客户TCP发送允许连接的报文段。这个允许连接的报文段也不包含应用层数据。但是，在报文段的首部却包含一个重要的信息。首先，SYN比特被置为1；其次，该TCP报文段首部的确认号字段被置为client _ isn+1；最后，服务器选择自己的初始序号(server_isn)，并将其放置到TCP报文段首部的序号宇段中。**即“我收到了你发起建立连接的 SYN 分组，该分组带有初始序号client_isn，我同意建立该连接并已经分配了缓存空间和控制变量，我自己的初始序号是server_isn”。该允许连接的报文段有时被称为SYNACK报文段**。
③、第三步：在收到 SYNACK 报文段后，客户也要给该连接分配缓存和变量。客户主机则向服务器发送另外一个报文段;这最后一个报文段对服务器的允许连接的报文段进行了确认(该客户通过将值 server_isn+1放置到TCP报文段首部的确认字段中来完成此项工作)。因为连接已经建立了，所以该SYN比特被置为0。该三次握手的第三个阶段可以在报文段负载中携带客户到服务器的数据。**即“我收到你的同意了，并接收到了你的server+isn序号，并开始传送数据”**。
参与一条TCP连接的两个进程中的任何一个都能终止该连接。当连接结束后，主机中的"资源" (即缓存和变量)将被释放。
假设客户打算关闭连接，客户应用进程发出一个关闭连接命令。这会引起客户TCP向服务器进程发送一个特殊的TCP报文段。这个特殊的报文段让其首部中的一个标志位即FIN比特被设置为1。当服务器接收到该报文段后，就向发送方回送一个确认报文段。然后，服务器发送它自己的终止报文段，其FIN比特被置为1。最后，该客户对这个服务器的终止报文段进行确认。此时，在两台主机上用于该连接的所有资源都被释放了。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200428173354852.png)
