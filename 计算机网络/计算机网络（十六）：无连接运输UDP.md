UDP只是做了运输协议能够做的最少工作 除了复用/分解功能及少量的差错检测外，如果应用程序开发人员选择UDP而不是TCP，则该应用程序差不多就是直接与IP打交道。
UDP从应用进程得到数据，附加上用于多路复用/分解服务的源和目的端口号字段，以及两个其他的小字段，然后将形成的报文段交给网络层。
网络层将该运输层报文段封装到一个IP数据报中，然后尽力地尝试将此报文段交付给接收主机。如果该报文段到达接收主机，UDP使用目的端口号将报文段中的数据交付给正确的应用进程。
在发送报文段之前，UDP发送方和接收方的运输层实体之间没有握手。正因为如此，UDP被称为是无连接的。DNS是一个通常使用UDP的应用层协议的例子。
当一台主机中的DNS应用程序想要进行一次查询时，它构造了DNS查询报文并将其交给 UDP。无须执行任何与运行在目的端系统中的UDP实体之间的握手，主机端的UDP为此报文添加首部字段，然后将形成的报文段交给网络层。
网络层将此UDP报文段封装迸一个IP数据报中，然后将其发送给一个名字服务器。在查询主机中的DNS应用程序则等待对该查询的响应。如果它没有收到响应(可能是由于底层网络丢失了查询或响) ，则要么试图向另一个名字服务器发送该查询，要么通知调用的应用程序它不能获得响应。
使用UDP的原因：
①、**关于何时、发送什么数据的应用层控制更为精细**。采用UDP时，只要应用进程将数据传递给UDP，UDP就会将此数据打包进UDP报文段并立即将其传递给网络层。在另一方面，TCP有一个拥塞控制机制，以便当源和目的主机间的一条或多条链路变得极度拥塞时来遏制运输层TCP发送方。TCP 仍将继续重新发送数据报文段直到目的主机收到此报文并加以确认，而不管可靠交付需要用多段时间。因为实时应用通常要求最小的发送速率，不希望过分地延迟报文段的传送，且能容忍一些数据丢失，TCP 服务模型并不是特别适合这些应用的需要。这些应用可以使用UDP，并作为应用的一部分来实现所需的、超出UDP的不提供不必要的报文段交付服务之外的额外功能。
②、**无需连接建立**。如我们后面所讨论的，TCP在开始数据传输之前要经过三次握手。UDP却不需要任何准备即可进行数据传输。因此UDP不会引人建立连接的时延。HTTP使用TCP而不是UDP，因为对于具有文本数据的web网页来说，可靠性是至关重要的。但是，HTTP中的TCP连接建立时延对于与下载Web文档相关的时延来说是一个重要因素。
③、**无连接状态**。TCP需要在端系统中维护连接状态。此连接状态包括接收和发送缓存、拥塞控制参数以及序号与确认号的参数。要实现TCP的可靠数据传输服务并提供拥塞控制，这些状态信息是必要的。在另一方面，UDP 不维护连接状态，也不跟踪这些参数。因此，某些专门用于某种特定应用的服务器当应用程序运行在UDP之上而不是运行在TCP上时，一般都能支持更多的活跃客户。
④、**分组首部开销小**。每个 TCP 报文段都有 20 字节的首部开销，而 UDP 仅有8字节的开销
UDP被用于RIP路由选择表的更新。更新的丢失能被最近的更新所替代，因此丢包、过期的更新是无所谓的，所以对于数据的完整性要求不高。
**TCP的拥塞控制会导致如因特网电话、视频会议之类的实时应用性能变得很差。而UDP中缺乏拥塞控制能够导致UDP发送方和接收方之间的高丢包率。**

## 1、UDP报文段结构：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200428172516694.png)

应用层数据占用UDP报文段的数据字段。例如，对于DNS应用，数据字段要么包含一个查询报文，要么包含一个响应报文。对于流式音频应用，音频抽样数据填充到数据字段UDP首部只有一个字段，每个字段由两个字节组成。
通过端口号可以使目的主机将应用数据交给运行在目的端系统中的相应进程(即执行分解功能)。
长度字段指示了在UDP报文段中的字节数(首部加数据)。因为数据字段的长度在一个UDP段中不同于在另一个段中，故需要一个明确的长度。
接收方使用检验和来检查在该报文段中是否出现了差错。实际上，计算检验和时，除了UDP报文段以外还包括了由首部的一些字段，但是我们忽略以便能从整体上看问题。
长度字段指明了包括首部在内的UDP报文段长度。

## 2、UDP检验和

UDP 检验和提供了差错检测功能。检验和用于确定当UDP报文段从源到达目的地移动时，其中的比特是否发生了改变。
发送方的UDP对报文段中的所有16 比特字的和进行反码运算，求和时遇到的任何溢出都被回卷（即最高位的溢出加到最低位），得到的结果被放在 UDP 报文段中的检验和字段。
**由于0xFFFF+0xFFFF最大值也只能是0x1FFFE，所以不会出现无限循环的情况。之所以使用反码是为了解决不同操作系统大小端的计算情况，使用反码即便字节的顺序调换，其结果也仅是字节顺序同步调换。**
为什么UDP首先提供了检验和，就像许多链路层协议也提供了差错检测那样，其原因是由于不能保证源和目的之间的所有链路都提供差错检测;这就是说，也许这些链路中的一条可能使用没有差错检测的协议。
此外，即使提文段经链路正确地传输，当报文段存储在某台路由器的内存巾时，也可能引入比特差错。在既无法确保连链路的可靠性，又无法确保内存巾的差错检测的情况下，如果端到端数据传输服务要提供差错检测. UDP就必须在端到端基础上在运输层提供差错检测。这是一个在系统设计中的端到端原则的例子。该原则表述为因为某种功能(在此时为差错检测)必须基于端到端实现：“与在较高级别提供这些功能的代价相比，在较低级别上设置的功能可能是冗余的或几乎没有价值的。”
虽然UDP提供差错检测，但它无法恢复差错。UDP的某种实现只是丢弃受损的报文段；其他实现是将受损的报文段交给应用程序并给出警告。
